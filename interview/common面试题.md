# 可信软件

我们要在每一个ICT基础设施产品和解决方案中，都融入信任、构建高质量，包括：

**安全性（Security）：**产品有良好的抗攻击能力，保护业务和数据的机密性、完整性和可用性。

**韧性（Resilience）：**系统受攻击时保持有定义的运行状态（包括降级），遭遇攻击后快速恢复并持续演进的能力。

**隐私性（Privacy）：**遵从隐私保护既是法律法规的要求，也是价值观的体现。用户应该能够适当地控制他们的数据的使用方式。信息的使用政策应该是对用户透明的。用户应该根据自己的需要来控制何时接收以及是否接收信息。用户的隐私数据要有完善的保护能力和机制。

**安全性（Safety）：**系统失效导致的危害不存在不可接受的风险，不会伤害自然人生命或危及自然人健康，不管是直接还是通过损害环境或财产间接造成的。

**可靠性和可用性（Reliability& Availability）：**产品能在生命周期内长期保障业务无故障运行，具备快速恢复和自我管理的能力，提供可预期的、一致的服务。



# 1、什么是分布式锁

分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用。

Redis 实现的分布式锁。



# 2、浏览器输入URL后发生了什么

合成URL、DNS域名解析 、建立TCP连接、http请求、关闭TCP连接、浏览器渲染



# 3、进程间通信方式

管道（需要共同的祖先）、消息队列、信号量、套接字、共享内存、写文件。



# 4、 Linux 中的用户模式和内核模式是什么含义

用户模式只能通过操作系统来操作硬件资源

内核模式直接操作硬件资源。

内核态：CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序。

用户态：只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取。



# 5、Linux内存申请

vmalloc 用于申请大块内存，虚拟地址连续，物理地址不一定连续，不能直接用于DMA，在进程地址空间有专门的一块。

kmalloc 用于申请小内存，由 slab 管理实现，一般至少小于4KB（page）。不能申请大于128K的数据。物理地址和虚拟地址都连续，可用于DMA操作。

malloc 

> DMA: direct memory access，也就是直接内存访问(可以理解为读写)。

golang使用的是tcmalloc，申请了arena（512G，申请空间）、bitmap（16G，用于GC）、spans（存放arena页的指针）



# 6、Linux 中的文件包括哪些

可执行文件、普通文件、目录、链接文件、设备文件、管道文件，快捷方式。

- 当为 **d** 则是目录
- 当为 **-** 则是文件；
- 若是 **l** 则表示为链接文档(link file)；
- 若是 **b** 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；
- 若是 **c** 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。



# 7、linux模块管理

内核模块的保存位置：/lib/modules/ 内核版本 /kernel/ 目录中

lsmod 列出模块

insmod 安装模块

rmmod 删除模块

modprobe  智能模块管理工具



# 8、linux chroot

chroot命令用来改变root用户目录。其作用如下：

> *增加了系统的安全性，限制了用户的权力。*
>
> *建立一个与原系统隔离的系统目录结构，方便用户的开发。*
>
> *切换系统的根目录位置，可以容灾，当发生灾难时可以切换目录。*



# 9、linux namespace

Linux namespace 实现了 6 项资源隔离，基本上涵盖了一个小型操作系统的运行要素，包括主机名、用户权限、文件系统、网络、进程号、进程间通信。

| namespace | 系统调用参数  | 隔离内容                   | 内核版本 |
| --------- | ------------- | -------------------------- | -------- |
| UTS       | CLONE_NEWUTS  | 主机和域名                 | 2.6.19   |
| IPC       | CLONE_NEWIPC  | 信号量、消息队列、共享内存 | 2.6.19   |
| PID       | CLONE_NEWPID  | 进程号                     | 2.6.19   |
| Network   | CLONE_NEWNET  | 网络设备、端口             | 2.6.19   |
| Mount     | CLONE_NEWNS   | 挂载点、文件系统           | 2.4.19   |
| User      | CLONE_NEWUSER | 用户和组                   | 3.8      |

隔离意味着可以抽象出多个轻量级的内核（容器进程），这些进程可以充分利用宿主机的资源，宿主机有的资源容器进程都可以享有，但彼此之间是隔离的，同样，不同容器进程之间使用资源也是隔离的，这样，彼此之间进行相同的操作，都不会互相干扰，安全性得到保障。

# 10、linux cgroups

cgroups 是Linux内核提供的一种可以限制单个进程或者多个进程所使用资源的机制，可以对 cpu，内存等资源实现精细化的控制，目前越来越火的轻量级容器 Docker 就使用了 cgroups 提供的资源限制能力来完成cpu，内存等部分的资源控制。

另外，开发者也可以使用 cgroups 提供的精细化控制能力，限制某一个或者某一组进程的资源使用。

典型的子系统介绍如下：

1. cpu 子系统，主要限制进程的 cpu 使用率。
2. cpuacct 子系统，可以统计 cgroups 中的进程的 cpu 使用报告。
3. cpuset 子系统，可以为 cgroups 中的进程分配单独的 cpu 节点或者内存节点。
4. memory 子系统，可以限制进程的 memory 使用量。
5. blkio 子系统，可以限制进程的块设备 io。
6. devices 子系统，可以控制进程能够访问某些设备。
7. net_cls 子系统，可以标记 cgroups 中进程的网络数据包，然后可以使用 tc 模块（traffic control）对数据包进行控制。
8. freezer 子系统，可以挂起或者恢复 cgroups 中的进程。
9. ns 子系统，可以使不同 cgroups 下面的进程使用不同的 namespace。

# 11、linux I/O模型

linux只有要5中I/O模型：

​	【同步】阻塞I/O（blocking IO）

​	【同步】非阻塞I/O (nonblocking I/O)

​	【同步】I/O 复用 (I/O multiplexing)

​	【同步】信号驱动I/O (signal driven I/O (SIGIO))

​	【异步】异步I/O (asynchronous I/O)

前四种模型(阻塞 IO, 非阻塞 IO, IO 复用, 信号驱动 IO)的主要区别在于第一阶段, 因为他们的第二阶段是一样的: 在数据从内核复制到调用者的缓冲区期间, 进程阻塞于 recvfrom 调用.

**阻塞IO模型**

进程会一直阻塞，直到数据拷贝完成 应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好。数据准备好后，从内核拷贝到用户空间，IO函数返回成功指示。

**非阻塞IO模型**

通过进程反复调用IO函数，在数据拷贝过程中，进程是阻塞的。

**IO复用模型**

主要是epoll、select和epoll。一个线程可以对多个IO端口进行监听，当socket有读写事件时分发到具体的线程进行处理。

**信号驱动IO模型**

信号驱动式I/O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。

**异步IO模型**

相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。

# 12、IO复用之select、poll、epoll简介

epoll是linux所特有，而select是POSIX所规定，一般操作系统均有实现。

**select**

select本质是通过设置或检查存放fd标志位的数据结构来进行下一步处理。

缺点：

单个进程可监视的fd数量被限制，即能监听端口的大小有限。32位默认是1024个，64位默认为2048个

对socket进行扫描时是线性扫描，即采用轮询方法，效率低。

需要维护一个用来存放大量fd的数据结构，会使得用户空间和内核空间在传递该结构时复制开销大



**poll**

poll本质和select相同，将用户传入的数据拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或主动超时，被唤醒后又要再次遍历fd。它没有最大连接数的限制，原因是它是基于链表来存储的，但缺点是：

1. 大量的fd的数组被整体复制到用户态和内核空间之间，不管有无意义。
2. poll还有一个特点“水平触发”，如果报告了fd后，没有被处理，那么下次poll时再次报告该ffd。



**epoll**

epoll支持水平触发和边缘触发，最大特点在于边缘触发，只告诉哪些fd刚刚变为就绪态，并且只通知一次。还有一特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一量该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。epoll的优点：

1. 没有最大并发连接的限制。
2. 效率提升，只有活跃可用的FD才会调用callback函数。
3. 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递。

| 名称   | 一个进程能打开连接数               | IO效率                                   | 消息传递方式                                     |
| ------ | ---------------------------------- | ---------------------------------------- | ------------------------------------------------ |
| select | 32位机器1024,64位机器2048          | io效率低                                 | 内核需要将消息传递到用户空间，都需要内核拷贝动作 |
| poll   | 无限制基于链表存储                 | io效率低                                 | 内核需要将消息传递到用户空间，都需要内核拷贝动作 |
| epoll  | 几乎无限制，上限很大,2G内存40w左右 | 只有活跃的socket才调用callback，io效率高 | 通过内核与用户空间共享一块内存来实现             |

# 13、linux性能优化

对于系统优化系统是为了提高系统的性能吧，我感觉一个系统做的工作越少并且做到极致，这样对于就能提升性能了。
那么你就要考虑你这台服务器是来做什么的是WEB，数据库，缓存，负载均衡等等，根据你的服务做的事情来优化把他发挥到极致。

- 硬件的选择

  内存、cpu、硬盘。经常的性能瓶颈是：磁盘IO问题、内存不足、CPU冲高。

- 关闭不必要服务和端口

  对于不必要的服务和端口必须关闭掉，提升性能和安全性

- 关闭GUI（不用图形界面时），提升性能

- 进程管理

  关闭不必要的经常，设置进程优先级和nice值、充分平均分配CPU

- 内核的优化

  内核参数优化/proc,提供了内核，处理器，内存，网络等相关参数：减少TCP建立中的TIME-WAIT sockets，修改最大进程数等。

- 内存调优

  设置虚拟内存，增大缓冲区。

- 服务优化

  遵循安全编码规范，控制并发数。

# 14、GRPC

一个高性能的RPC框架，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。

它的主要特性包括三个方面。

- 通信协议采用了 HTTP/2，因为 HTTP/2 提供了连接复用、双向流、服务器推送、请求优先级、首部压缩等机制
- IDL 使用了ProtoBuf，ProtoBuf 是由 Google 开发的一种数据序列化协议，它的压缩和传输效率极高，语法也简单
- 多语言支持，能够基于多种语言自动生成对应语言的客户端和服务端的代码。

# 15、rabbitMQ的消息模型

5种模型

- HolleWorld模型：**点对点模型**，一个生产者、一个消息队列、一个消费者
- WorkQueues模型：**任务模型**（点对多模型），一个生产者、一个消息队列、多个消费者
- publish/Subscribe模型：**广播模型**（广播模型的交换机与队列之间是任意绑定）：一个生产者、一个交换机、多个消息队列、多个消费者。一个消息队列绑定一个消费者。
- route模型：**路由模型**：一个生产者、一个direct交换机、多个消息队列和多个消费者，一个交换机绑定多个队列，一个消息队列绑定一个消费者
- Topics模型：**动态路由模型**：一个生产者、一个topic交换机、多个消息队列和多个消费者，一个交换机绑定多个队列，一个消息队列绑定一个消费者

# 16、MongoDB为什么快

写操作MongoDB比传统数据库快的根本原因是Mongo使用的内存映射技术 － **写入数据时候只要在内存里完成就可以返回给应用程序，这样并发量自然就很高**。而保存到硬体的操作则在后台异步完成。注意MongoDB在2.4就已经是默认安全写了（具体实现在驱动程序里），所以楼上有同学的回答说是”默认不安全“应该是基于2.2或之前版本的。

读操作MongoDB快的原因是： 1）MongoDB的设计要求你**常用的数据（working set)可以在内存里装下。这样大部分操作只需要读内存，自然很快**。 2）文档性模式设计一般会是的你所需要的数据都相对集中在一起（内存或硬盘），大家知道硬盘读写耗时最多是随机读写所产生的磁头定位时间，数据集中在一起则减少了关系性数据库需要从各个地方去把数据找过来（然后Join）所耗费的随机读时间

# 17、网络分层模型

// OSI七层模型
物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
// TCP/IP四层模型
网络接口层（物理层、数据链路层）、网络层、传输层、应用层（会话层、表示层、应用层）
// 五层模型
物理层、数据链路层、网络层、传输层、应用层

// 对应层作用
物理层：定义一些电器，机械，过程和规范，如集线器 （没有寻址的概念）// 单位bit
数据链路层：定义如何格式化数据，支持错误检测；（//交换机通过MAC地址转发数据，逻辑链路控制）// 单位是帧
网络层：定义一个逻辑的寻址，选择最佳路径传输，路由数据包，（//路由器，ip协议，实现寻址）// 单位是数据报
传输层：提供可靠和尽力而为的传输；（TCP,UDP等协议,负责网络传输和会话建立）// 单位是报文
会话层：控制会话，建立管理终止应用程序会话
表示层：格式化数据；（如加密等）
应用层：控制应用程序（telnet, ssh, http, ftp, smtp等协议，为应用程序提供网络服）

# 18、对称加密与非对称加密

对称加密是指加解密使用的是同样的密钥
优点：简单快速
缺点：容易被拦截

非对称加密使用了一对密钥，公钥和私钥。私钥由解密方安全保管，公钥可以发给任何请求它的人。数据使用公钥加密，私钥解密。因为私钥不通过网络发送出去，所以非对称加密的安全性很高。
优点：安全性高
缺点：不是那么高效快速

# 19、MySQL事务四大特性

原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)

// Mysql怎么保证持久性的？
将数据存入磁盘上
// mysql 两种引擎的区别
Innodb引擎 事务安全的   表级别
MyIASM引擎 非事务安全的  行级别  快速

// 索引
hash
btree 高效
b+tree 磁盘读写代价更低

// 什么时候不要用索引
经常增删改的列不要建立索引；
有大量重复的列不建立索引；
数据量不大的情况下

// 索引失效的情况
索引中不能有列的值为NULL
在一个SELECT语句中，索引只能使用一次
不要用 in 要用exist
尽量不要or，用union

# 20、redis是单线程还是多线程，为什么快

在 Redis4.0 之前，Redis 是单线程运行的，redis 6.0 之后可以多线程启动 
为什么快：

- 内存存储：Redis是使用内存(in-memeroy)存储,没有磁盘IO上的开销
- 单线程实现：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销
- 非阻塞IO：Redis使用多路复用IO技术，在poll，epoll，kqueue选择最优IO实现
- 优化的数据结构：Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能

# 21、redis持久化方式与优缺点

默认的RDB(Redis DataBase)。 按照一定的时间将内存的数据以快照的形式存在磁盘中，产生的对应快照文件dump.rdb。通过配置文件中的save参数来定义快照的周期。

AOF(Append Only File)。将redis每次执行的命令存到单独的日志文件中，当重启redis时会从持久化的日志中恢复数据。

优缺点
RDB 只有一个dump.rdb文件，方便持久化。容灾好，数据恢复快，速度快，周期执行
AOF 数据安全，速度慢，单次执行

# 22 、Nginx是内核态是用户态

epoll模型是Nginx处理性能高的根本原因，但并不是所有的情况下都是epoll大获全胜的，如果本身提供静态服务的就文件相对较少，Apache的select模型或许比epoll更高性能。

> nginx在用户态完成切换，io处理的内核态的epoll异步IO。

# 23、进程与线程的区别

进程是资源分配的最小单位，线程是CPU调度的最小单位
线程在进程下行进
一个进程可以包含多个线程
进程数据共享难，线程数据共享容易。
类似于火车与车厢的关系

# 24、微服务

它采用 UNIX 设计的哲学，每种服务只做一件事，是一种松耦合的能够被独立开发和部署的无状态化服务（独立扩展、升级和可替换）。

# 25、HTTP状态码

1**	信息，服务器收到请求，需要请求者继续执行操作
2**	成功，操作被成功接收并处理
3**	重定向，需要进一步的操作以完成请求
4**	客户端错误，请求包含语法错误或无法完成请求 //规则权限
5**	服务器错误，服务器在处理请求的过程中发生了错误 //服务器，网关

# 26、TCP三次握手、四次挥手，timewait，closewait状态

// TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。

// 三次握手
第一次：客户端发包SYN (SYN=1, seq=x) //这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
第二次：服务器发包ACK (SYN=1, ACK=1, seq=y, ACKnum=x+1): //服务端发送和接收能力也是正常的。
第三次：客户端发包ACK (ACK=1，ACKnum=y+1) // 客户端接收能力正常

// 四次挥手 
第一次：客户端发包想要关闭连接FIN (FIN=1，seq=x)
第二次：服务器发送确认包ACK (ACK=1，ACKnum=x+1) //此时进入closewaite 状态
第三次：服务器发送结束连接的请求FIN (FIN=1，seq=y)
第四次：客户发送确认关闭包ACK (ACK=1，ACKnum=y+1) //此时进入timewaite 状态

# 27、socket编程

// socket 是对 TCP/IP 协议族的一种封装,利用三元组（ip地址，协议，端口）
// Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –> 读写(write/read) –> 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。
socket() 创建套接字
bind() 分配套接字地址
listen() 等待连接请求
accept() 允许连接请求
read()/write() 数据交换
close() 关闭连接

# 28、https请求过程

客户端发起HTTPS连接
服务端发送证书
客户端验证服务端发来的证书(验证证书、发送随机数、生成握手、服务器检验、客户端确认、完成握手)

# 29、设计原则

OCP	开闭原则	对扩展开放，对修改关闭
SRP	单一职责原则	一个类只负责一个功能领域中的相应职责
LSP	里氏代换原则	所有引用基类的地方必须能透明地使用其子类的对象
DIP	依赖倒转原则	依赖于抽象，不能依赖于具体实现
ISP	接口隔离原则	类之间的依赖关系应该建立在最小的接口上
CARP	合成/聚合复用原则	尽量使用合成/聚合，而不是通过继承达到复用的目的
LOD	迪米特法则	一个软件实体应当尽可能少的与其他实体发生相互作用

# 30、TCP与UDP的区别

1、TCP基于连接有三次握手与UPD无连接；
2、对系统资源的要求（TCP较多，UDP少）；
3、UDP程序结构较简单；
4、流模式与数据报模式 ；
5、TCP保证数据正确性，UDP可能丢包；
6、TCP保证数据顺序，UDP不保证。

UDP 适合消息的多播发布，从单个点向多个点传输消息，组播。

# 31、乐观锁与悲观锁

1. 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
2. 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。

#  32、容器、应用程序启动失败排查

看日志，查看是否IP端口冲突、内存不足，非法参数，内部引导错误。

# 33、http能不能一次连接多次请求，不等后端返回

可以http1.0只能链接一次，http1.1只要不断开可以连接多次。

**HTTP/1.0** 中 Connection 默认是 **close** 的，即每次请求都会重新建立和断开 TCP 连接；
**HTTP/1.1** 中 Connection 默认是 **keep-alive** 的，即tcp连接可以**复用**，不用每次都要重新建立和断开 TCP 连接。

# 34、说说CSRF

跨站请求伪造，简单来说，攻击者利用一些技术手段去欺骗用户浏览器去访问一些曾经认证过的网站而执行一些操作。

防御：

1、检查Referer字段

2、校验token

3、可以校验一些自定义加密串authinfo

# 35、IPFS

*IPFS 是*一个分布式的web, 点到点超媒体协议. 可以让我们的互联网速度更快, 更加安全, 并且更加开放

# 36、如何放在Dos攻击和DDos攻击

DoS是一种利用单台计算机的攻击方式。而DDOS（Distributed Denial of Service，分布式拒绝服务）是一种基于DOS的特殊形式的拒绝服务攻击，是一种分布、协作的大规模攻击方式，主要瞄准比较大的站点，比如一些商业公司、搜索引擎和政府部门的站点。

预防

1、关闭不必要的端口、服务

2、定期扫描

3、设备本机防火墙、ip白名单

4、限制访问次数

5、设置备用服务器。

# 37、公钥、私钥、数字证书的关系是什么

公钥是公开的，不需要保密

私钥是由证书持有人自己特有，并且必须妥善保管和注意保密。

数字证书就是经过CA认证过的公钥（一个数字文件），因此数字证书和公钥一样是公开的。

> *那么私钥就是这把锁的的一把钥匙，若的钥匙丢了，锁还有什么存在的价值呢？*，直接申请换新的吧
