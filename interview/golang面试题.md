# 1、make和new的区别

make适用于应用类型channel，map，slice，返回申请空间后的应用对象

new适用于值类型int，float、array，struct等，返回初始零值的指针对象



# 2、了解空指针吗

当一个指针被定义后没有分配到任何变量时，它的值为 nil。

nil 指针也称为空指针。

```go
var ptr *int
```



# 3、如果用range修改切片元素的值，会发生什么

range时会拷贝切片的副本，修改切片不会影响遍历。

range map时修改map会影响遍历。



# 4、怎么用go去实现一个set集合

set集合无重复数据，使用空结构struct{}几乎不占用内心。unsafe.Sizeof(struct{})为0。将map的val设置为空结构体，即可得到一个高效的set集合。



# 5、map怎么顺序读取

将map的key存入slice，对slice排序。对map取key。

将map的key存入slice，对slice排序。用sort.Slice排序，然后对slice取值。



# 6、结构体比较

如果struct的所有成员都可以比较，则该struct就可以通过==或!=进行比较是否相同，比较时逐个项进行比较，如果每一项都相等，则两个结构体才相等，否则不相等，只能比较是否相对，不能比较大小

相同类型的结构体才能进行比较，结构体是否相同不但与属性类型有关，还与属性顺序相关；

<font color="red">值类型才能比较，引用类型不能比较</font>



# 7、reflect.DeepEqual

DeepEqual函数用来判断两个值是否深度一致。



# 8、有时候会遇到一些空的结构体，这个目的是什么

空结构体不占空间，可以占位，可以做不做消息处理的消息传递，节约空间，提升性能。



# 9、go程和线程的区别

内存消耗更少：Goroutine所需要的内存通常只有2kb，而线程则需要1Mb（500倍）。

创建与销毁的开销更小：go程是用户级由go程自己管理，线程是系统级，需要向系统申请。

切换开销更小：这是goroutine于线程的主要区别，也是golang能够实现高并发的主要原因。线程的调度方式是抢占式的，如果一个线程的执行时间超过了分配给它的时间片，就会被其它可执行的线程抢占。



# 10、defer函数遇到return以后是怎么执行的

return 不是原子操作，执行过程是: 保存返回值(若有)-->执行defer（若有）-->执行ret跳转。



# 11、GMP模型

Goroutine主要概念如下：

- G（Goroutine）: 即Go协程，每个go关键字都会创建一个协程。
- M（Machine）： 工作线程，在Go中称为Machine。
- P(Processor): 处理器（Go中定义的一个摡念，不是指CPU），包含运行Go代码的必要资源，也有调度goroutine的能力。

M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队列，P可以调度G交由M执行。

程序中可以使用`runtime.GOMAXPROCS()`设置P的个数，一般是一个P一个CPU。

策略有：队列轮转、系统调用、 工作量窃取（空闲的P会将其他P中的G偷取一部分过来，一般每次偷取一半）



# 12、Golang内存模型

golang使用tcmalloc申请内存。

预申请的内存划分为spans、bitmap、arena三部分。其中**arena即为所谓的堆区**，应用中需要的内存从这里分配。其中spans和bitmap是为了管理arena区而存在的。

arena的大小为512G，为了方便管理把arena区域划分成一个个的page，每个page为8KB,一共有512GB/8KB个页；

spans区域存放span的指针，每个指针对应一个page，所以span区域的大小为(512GB/8KB)*指针大小8byte = 512M

bitmap区域大小也是通过arena计算出来，不过主要用于GC。

> *spans 管理 （8的倍数byte对象），超过32KB的对象由特殊的class管理。*

1. Golang程序启动时申请一大块内存，并划分成spans、bitmap、arena区域
2. arena区域按页划分成一个个小块
3. span管理一个或多个页
4. mcentral管理多个span供线程申请使用
5. mcache作为线程私有资源，资源来源于mcentral

# 13、Golang垃圾回收

垃圾回收的核心就是把未引用到的回收，还给操作系统，或者提供后序内存分配使用。

gcmarkBits标记

三色标记法：

- 白色：对象未被标记，gcmarkBits对应的位为0（该对象将会在本次GC中被清理）
- 灰色：对象还在标记队列中等待
- 黑色：对象已被标记，gcmarkBits对应的位为1（该对象不会在本次GC中被清理）

初始状态下所有对象都是白色的。接下来就开始分析灰色对象，分析A时，A没有引用其他对象很快就转入黑色。最终，黑色的对象会被保留下来，白色对象会被回收掉。

Golang中的STW（Stop The World）就是停掉所有的goroutine，专心做垃圾回收，待垃圾回收结束后再恢复goroutine。

优化算法：写屏障、辅助GC

回收方式：超过阈值回收、定时回收（2分钟）、手动回收runtime.GC()

# 14、golang内存逃逸

内存逃逸是指栈上内存逃逸到了堆上，通过编译参数-gcflags=-m 分析内存是否逃逸

逃逸场景

**指针逃逸**：方法/函数返回指针时，内存会逃逸到堆上

**栈空间不足逃逸**：函数内变量申请的资源过多（如make([]int,10000)），实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。

栈空间由处理器决定一般是2-4M，极少数是32兆。

**动态类型逃逸**：interface{}传参时，编译期间很难确定其参数的具体类型，也容易引起内存逃逸

**闭包引用对象逃逸**：闭包引用了函数的局部变量时，会发生内存逃逸。

# 15、golang map实现原理

map使用哈希表作为底层实现，数据结构是hash数组+桶内的key-value数组+溢出的桶链表。

每个桶可以存储8个键值对。通过地址链的方式解决hash冲突。

增量扩容（2倍）：当平均每个bucket存储超过6.5个key，会增量扩容。

等量扩容（内部整理移动）：所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。

# 16、golang slice实现原理

底层也是一个数组，容量满了时会扩容。

```go
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```

如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍；
如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍；

# 17、golang chan实现原理

原理：以通信的方式共享内存。底层是安全队列FIFO，不设置缓冲就是同步队列，设置了就是带缓冲的队列。

# 18、Golang中的乐观锁与悲观锁

sync/atomic

​	Golang中有一个 atomic 包，可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，这个包应用的便是乐观锁的原理。不过这个包只支持int32/int64/uint32/uint64/uintptr这几种数据类型的一些基础操作（增减、交换、载入、存储等）

sync

​	Golang中的sync包，提供了各种锁，如果使用了这个包，基本上就以悲观锁的工作模式了。Mutex是悲观锁、RWMutex是乐观锁。

# 19、golang 读写锁底层实现

读写锁内部仍有一个互斥锁，用于将两个写操作隔离开来，其他的几个都用于隔离读操作和写操作。

**RLock()实现逻辑**

- 增加读操作计数，即readerCount++
- 阻塞等待写操作结束(如果有的话)

**RUnlock()实现逻辑**

- 减少读操作计数，即readerCount--
- 唤醒等待写操作的协程（如果有的话）

# 20、golang可以==比较的有

- 值类型可以直接比较

- 复合类型（数组和结构体），只有每个元素(成员)可比较，而且类型和值都相等时，两个复合元素才相等

- 相同类型的channel可以比较。

- slice、map、函数不能比较。但是可以用reflect.DeepEqual或者cmp包来比较

- 类型再定义(type A string)不可比较，是两种不同的类型

- 类型别名(type A = string)可比较，是同一种类型。

  

# 21、golang匿名函数和闭包的区别

匿名函数没有函数名，只有函数体，它只有在被调用的时候才会被初始化。

匿名函数一般被当作一种类型被赋值给类型为函数类型的变量，经常用于实现回调函数和闭包等功能。

闭包一般按正常的函数定义，闭包  = 环境引用 + 函数

> *当匿名函数实现闭包功能时和闭包并无什么差异* ，要注意内存逃逸

匿名函数作用就是语音简洁，提取重复代码块儿，方便使用与维护。

